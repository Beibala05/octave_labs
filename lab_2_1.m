% Примерные данные (матрица A и вектор b)
A = [-13, 80, 2, 0; 
    64, 9, 0, -5; 
    0, 12, -9, 128; 
    0, 27, 100, 3];
b = [64; 29; 0; 231];  % Вектор b с 4 значениями

% Шаг 1: Решение системы Ax = b с помощью встроенной функции
x = A\b; 
disp('Решение системы Ax = b:');
disp(x);

% Шаг 2: Приведение матрицы A к диагональному преобладанию
n = size(A, 1);  % Размерность матрицы A
for i = 1:n
    for j = i+1:n  % Сравнение только с последующими строками
        if abs(A(i,i)) < sum(abs(A(i,:))) - abs(A(i,i))
            % Перестановка строк
            A([i j], :) = A([j i], :); 
            b([i j]) = b([j i]); 
        end
    end
end

disp('Матрица A с диагональным преобладанием:');
disp(A);
disp('Вектор b после перестановок:');
disp(b);

% Шаг 3: Проверка, что решение Ax1 = b1 совпадает с решением Ax = b
x1 = A\b;
disp('Решение системы Ax1 = b1:');
disp(x1);

if norm(x - x1) < 1e-4
    disp('Решения совпадают с заданной точностью.');
else
    disp('Решения не совпадают.');
end

% Шаг 4: Реализация метода простой итерации
% Настройки
max_iter = 100;          % Максимальное число итераций
tol = 1e-4;             % Заданная точность
x_iter = zeros(n, 1);   % Начальная итерация
x_prev = zeros(n, 1);   % Предыдущая итерация

epsilon = 1e-4;         % Заданная точность
results_table = zeros(max_iter, n + 2);  % Таблица результатов

for k = 1:max_iter
    x_prev = x_iter;  % Сохраняем предыдущую итерацию
    for i = 1:n
        % Стандартная формула для простой итерации
        x_iter(i) = (b(i) - A(i, [1:i-1, i+1:n]) * x_prev([1:i-1, i+1:n])) / A(i,i);
    end
    
    % Заполнение результатов в таблицу
    results_table(k, 1:n) = x_iter';  % Текущие значения x
    results_table(k, n + 1) = norm(x_iter - x_prev);  % Норма изменения x
    results_table(k, n + 2) = ((1 - b(1)) / b(1)) * epsilon;  % Значение ((1 - b) / b) * epsilon
    % Вычисление разности между текущим и предыдущим вектором
    results_table(k, n + 1) = norm(x_iter - x_prev);  % Норма разности x_i - x_(i-1)

    % Проверка на достигнутую точность
    if norm(x_iter - x_prev) < tol
        disp(['Решение достигнуто на итерации: ', num2str(k)]);
        break;  % Завершить при достижении точности
    end
end

% Шаг 5: Определение номера итерации, на которой достигнута заданная точность
iteration_reached = find(results_table(:, n + 1) < tol, 1);
if ~isempty(iteration_reached)
    disp(['Номер итерации, на которой достигнута заданная точность: ', num2str(iteration_reached)]);
else
    disp('Заданная точность не была достигнута.');
end

% Шаг 6: Выписка решения системы x* соответствующей найденному номеру итерации
if ~isempty(iteration_reached)
    x_star = results_table(iteration_reached, 1:n)';  % Система x*, где x* = x_i при достигнутой точности
    disp('Соответствующее решение x*:')
    disp(x_star);
end

% Шаг 7: Вычисление невязки R = Ax* - b
if ~isempty(iteration_reached)
    R = A * x_star - b;  % Невязка
    disp('Невязка R = Ax* - b:')
    disp(R);
end

% Визуализация результатов
disp('Таблица результатов итераций:');
disp('Номер итерации | x1_i | x2_i | x3_i | x_i - x_(i-1) | ((1 - b) / b) * epsilon');
disp([(1:k)', results_table(1:k, :)]);

